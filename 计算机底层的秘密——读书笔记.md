# cpu

## 计算能力是怎么来的

![image-20241103173900884](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103173900884.png)

无论程序员编写的程序多么复杂，软件承载的功能最终都是通过这个晶体管简单的开闭完成的  

现在有了晶体管，也就是开关，在此基础之上就可以搭积木了，你随手搭建出来这样三种组合：

- 两个开关只有同时打开电流才会通过，灯才会亮

- 两个开关中只要有一个打开电流就能通过，灯就会亮

- 当开关关闭时电流通过灯会亮，打开开关灯反而电流不能通过灯会灭

上述组合分别就是：与门，AND Gate、或门，OR gate、非门，NOT gate

给定足够的AND、OR以及NOT门，就可以实现任何一个逻辑函数，除此之外我们不需要任何其它类型的逻辑门电路，这时我们认为{AND、OR、NOT}就是逻辑完备的。  

## 神奇的记忆能力

电路怎么能保存信息呢？这个电路有记忆功能  

![image-20241103174123097](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103174123097.png)

这是两个NAND门的组合，不要紧张，NAND也是设计的与或非门组合而成的，所谓NAND门就是与非门，先与然后取非  

比较独特的是该电路的组合方式，**一个**NAND**门的输出是两一个**NAND**门的输入**，该电路的组合方式会生成一种很有趣的特性，**只要给**S**和**R**段输入**1**，那么这个电路只会有两种状态**:

- 要么a端为1，此时B=0、A=1、b=0；

- 要么a端为0，此时B=1、A=0、b=1;

不会再有其他可能了，**我们把**a**端的值作为电路的输出**。

现在为保存信息你需要同时设置S端和R端，但你的输入是有一个，为此你对电路进行了简答的改造：  

![image-20241103174318352](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103174318352.png)

当D为0时，整个电路保存的就是0，否则就是1。  

## 指令集

指令集告诉我们 CPU 可以执行什么指令，每种指令需要提供什么样的操作数。不同类型的CPU会有不同的指令集。  

## 指挥家

现在我们的电路有了计算功能、存储功能，还可以通过指令告诉该电路执行什么操作，还有一个问题没有解决。  这个问题就是靠什么来协调靠什么来同步各个部分让它们协同工作呢？  假设我们要计算1+1，这两个数分别来自寄存器R1 和 R2，要知道寄存器中可以保存任意值，我们怎么能确保加法器开始工作时R1****R2中在这一时刻保存的都是1而不是其它数？ 

负责指挥角色的就是时钟信号。时钟信号就像指挥家手里的拿的指挥棒，**指挥棒挥动一下整个乐队会整齐划一的有个相应动作**，同样的，在时钟信号的每一次电压改变，整个电路中的各个寄存器(也就是整个电路的状态)会更新一下，这样我们就能确保整个电路协同工作不会这里提到的问题。

CPU的主频是说一秒钟指挥棒挥动了多少次，当然主频越高CPU在一秒内完成的操作也就越多  

# 进程与线程

## 同步调用

### 同一个线程间的同步调用

一般的函数调用都是同步的，就像这样：  

```
funcA() {
    // 等待函数funcB执行完成
    funcB();
    // 继续接下来的流程
}
```

funcA调用funcB，那么在funcB执行完前，funcA中的后续代码都不会被执行，也就是说funcA必须**等待**funcB执行完成，就像这样：  

![image-20241103191308388](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103191308388.png)

一般来说，像这种同步调用，funcA和funcB是运行在同一个线程中的，这是最为常见的情况。  

### 不同线程间的同步调用

但值得注意的是，即使运行在两个不能线程中的函数也可以进行同步调用，像进行IO操作时实际上底层是通过系统调用的方式向操作系统发出请求的，比如磁盘文件读取：  

```
read(file, buf);
```

阻塞式I/O，在read函数返回前程序是无法继续向前推进的  

```
read(file, buf);
// 程序暂停运行，
// 等待文件读取完成后继续运行
```

![image-20241103191508337](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103191508337.png)

只有当read函数返回后程序才可以被继续执行。

当然，这也是同步调用，但是和上面的同步调用不同的是，函数和被调函数运行在不同的线程中。

>同步调用和函数与被调函数是否运行在同一个线程是没有关系的。  

## 异步调用

以磁盘文件读取为例。在函数的同步调用方式下，文件读取完之前调用方是无法继续向前推进的，但如果read函数可以异步调用情况就不一样了。

假如read函数可以异步调用的话，即使文件还没有读取完成，read函数也可以立即返回。

```
read(file, buff);
// read函数立即返回
// 不会阻塞当前程序
```

![image-20241103191637601](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103191637601.png)

在异步这种调用方式下，调用方不会被阻塞，函数调用完成后可以**立即**执行接下来的程序。

这时异步的重点就在于调用方接下来的程序执行可以和文件读取**同时**进行，从上图中我们也能看出这一点，这就是异步的高效之处。

> 现代磁盘想内存copy数据时无需借助CPU的帮助，这就是所谓的DMA(Direct Memory Access)  

### 异步调用感知方式

在同步调用下，调用方不再继续执行而是暂停等待，被调函数执行完后很自然的就是调用方继续执行，那么异步调用下调用方怎知到被调函数是否执行完成呢？  

这就分为了两种情况：

1. 调用方根本就不关心执行结果

2. 调用方后续需要知道执行结果

第一种情况比较简单，该情况无需讨论。

第二种情况下就比较有趣了，通常有两种实现方式：

一种是通知机制，也就是说当任务执行完成后发送信号用来通知调用方任务完成，注意这里的信号就有很多实现方式了，Linux中的signal，或者使用信号量等机制都可以实现。

另一种是就是回调，也就是我们常说的callback

>eg:
>
>假定处理一次用户请求需要经过步骤A、B、C然后读取数据库，数据库读取完成后需要经过步骤D、E、F.
>
> 一个请求需要经过七个步骤，其中前三个是在主线程中完成的，后四个是在数据库线程中完成的，那么数据库线程是怎么知道查完数据库后要处理D、E、F这几个步骤呢？  
>
>将D、E、F这几个步骤封装到第一个函数中，我们将该函数命名为handle_DEF_after_DB_query:  
>
>```
>void handle_DEF_after_DB_query () {
>    D;
>    E;
>    F;
>}
>```
>
>这样主线程在发送数据库查询请求时将该函数一并当做参数传递过去：  
>
>```
>DB_query(request, handle_DEF_after_DB_query);
>```
>
>数据库线程处理完查询后直接调用handle_DEF_after_DB_query就可以了，这就是回调函数的作用。
>
>也有的同学可能会有疑问，为什么这个函数要传递给数据库线程而不是数据库线程自己定义自己调用呢？
>
>因为从软件组织结构上讲，这不是数据库线程该做的工作。
>
>数据库线程需要做的仅仅就是查询数据库、然后调用一个处理函数，
>
>**至于这个处理函数做了些什么数据库线程根本就不关心，也不应该关心**。
>
>你可以传入各种各样的回调函数。也就是说数据库系统可以针对回调函数这一抽象的函数变量来编程，从而更好的应对变化，因为回调函数的内容改变不会影响到数据库线程的逻辑，而如果数据库线程自己定义处理函数那么这种设计就没有灵活性可言了。
>
>而从软件开发的角度看，假设数据库线程逻辑是其它团队研发的，并用作库提供给其它团队，当数据库团队在研发时怎么可能知道数据库查询后该怎么处理呢，因此该团队在编写代码时简单的使用一个回调函数即可。
>
>与此同时，显然只有使用方才知道查询完数据库后该做些什么，因此使用方在使用时简单的传入这个回调函数就可以了。
>
>这样数据库线程的团队就和使用方团队就实现了所谓的解耦。

## CPU空闲时在干嘛

操作系统是用队列来管理进程的，那么很显然，如果队列已经为空，那么说明此时操作系统内部没有进程需要运行，这是 CPU 就空闲下来了，此时，我们需要做点什么，就像这样  

```
if (queue.empty()) {
	do_someting();
}
```

这些编写内核代码虽然简单，但内核中到处充斥着 if 这种异常处理的语句，这会让代码看起来一团糟，**因此更好的设计是没有异常**，那么怎样才能没有异常呢？

很简单，**那就是让队列永远不会空**，这样调度器永远能从队列中找到一个可供运行的进程。

而这也是为什么链表中通常会有哨兵节点的原因，就是为了避免各种判空，这样既容易出错也会让代码一团糟。

![image-20241103222552112](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103222552112.png)

就这样，**内核设计者创建了一个叫做空闲任务的进程**，这个进程就是Windows 下的我们最开始看到的“系统空闲进程”，在 Linux 下就是第 0号进程。

当其它进程都处于不可运行状态时，调度器就从队列中取出空闲进程运行，显然，**空闲进程永远处于就绪状态，且优先级最低**。

CPU 设计者早就考虑到系统会存在空闲的可能，因此设计了一条机器指令，这个机器指令就是halt 指令，停止的意思。

这条指令会让部分CPU进入休眠状态，从而**极大减少对电力的消耗**，通常这条指令也被放到循环中执行，原因也很简单，就是要维持这种休眠状态。

值得注意的是，halt 指令是特权指令，也就是说只有在内核态下 CPU 才可以执行这条指令，程序员写的应用都运行在用户态，因此你没有办法在用户态让 CPU 去执行这条指令。

此外，不要把进程挂起和 halt 指令混淆，当我们调用 sleep 之类函数时，暂停运行的只是进程，此时如果还有其它进程可以运行那么 CPU 是不会空闲下来的，当 CPU 开始执行halt指令时就意味着系统中所有进程都已经暂停运行。

# 编译器是如何工作的

假定我们有一段程序：  

```
while (y < z) {
    int x = a + b;
    y += x;
}
```

那么编译器是怎样把这一段程序人类认识的程序转换为CPU认识的二进制机器指令呢？

## 1. 提取出每一个单词：词法分析

首先编译器要把源代码中的每个“单词”提取出来，在编译技术中“单词”被称为**token**。其实不只是每个单词被称为一个token，除去单词之外的比如左括号、右括号、赋值操作符等都被称为token。

从源代码中提取出token的过程就被称为词法分析，Lexical Analysis。经过一遍词法分析，编译器得到了以下token：  

```
T_While while
T_LeftParen （
T_Identifier y
T_Less <
T_Identifier z
T_RightParen )
T_OpenBrace {
T_Int int
T_Identifier x
T_Assign =
T_Identifier a
T_Plus +
T_Identifier b
T_Semicolon ;
T_Identifier y
T_PlusAssign +=
T_Identifier x
T_Semicolon ;
T_CloseBrace }
```

## 2. 这些token想表达什么意思：语法分析  

有了这些token之后编译器就可以根据语言定义的语法恢复其原本的结构，怎么恢复呢？  

原来，编译器在扫描出各个token后根据规则将其用树的形式表示出来，这颗树就被称为**语法树**。  

![image-20241103223151818](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20241103223151818.png)

## 3. 语法树是不是合理的：语义分析  

有了语法树后我们还要检查这棵树是不是合法的，比如我们不能把一个整数和一个字符串相加、比较符左右两边的数据类型要相同，等等。

这一步通过后就证明了程序合法，不会有编译错误。

![image-20241103223227008](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20241103223227008.png)

## 4. 根据语法树生成中间代码：代码生成

语义分析之后接下来编译器遍历语法树并用另一种形式来表示，用什么来表示呢？那就是中间代码， intermediate representation code，简称**IR code**。

上述语法树可能就会表示为这样的中间代码：

```
Loop: x = a + b
    y = x + y
    _t1 = y < z
    if _t1 goto Loop
```

## 5. 中间代码优化  

在生成中间代码后要对其进行优化，我们可以看到，实际上可以把x = a + b这行代码放到循环外，因为每次循环都不会改变x的值，因此优化后就是这样了：  

```
	x = a + b
Loop: y = x + y
    _t1 = y < z
    if _t1 goto Loop
```

中间代码优化后就可以生成机器指令了  

## 6. 代码生成

将上述优化后的中间代码转换为机器指令：

```
	add $1, $2, $3
Loop: add $4, $1, $4
	slt $6, $1, $5
	beq $6, loop
```

最终，编译器将程序员认识的代码转换为了CPU认识的机器指令。  