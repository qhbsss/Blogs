# cpu

## 计算能力是怎么来的

![image-20241103173900884](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103173900884.png)

无论程序员编写的程序多么复杂，软件承载的功能最终都是通过这个晶体管简单的开闭完成的  

现在有了晶体管，也就是开关，在此基础之上就可以搭积木了，你随手搭建出来这样三种组合：

- 两个开关只有同时打开电流才会通过，灯才会亮

- 两个开关中只要有一个打开电流就能通过，灯就会亮

- 当开关关闭时电流通过灯会亮，打开开关灯反而电流不能通过灯会灭

上述组合分别就是：与门，AND Gate、或门，OR gate、非门，NOT gate

给定足够的AND、OR以及NOT门，就可以实现任何一个逻辑函数，除此之外我们不需要任何其它类型的逻辑门电路，这时我们认为{AND、OR、NOT}就是逻辑完备的。  

## 神奇的记忆能力

电路怎么能保存信息呢？这个电路有记忆功能  

![image-20241103174123097](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103174123097.png)

这是两个NAND门的组合，不要紧张，NAND也是设计的与或非门组合而成的，所谓NAND门就是与非门，先与然后取非  

比较独特的是该电路的组合方式，**一个**NAND**门的输出是两一个**NAND**门的输入**，该电路的组合方式会生成一种很有趣的特性，**只要给**S**和**R**段输入**1**，那么这个电路只会有两种状态**:

- 要么a端为1，此时B=0、A=1、b=0；

- 要么a端为0，此时B=1、A=0、b=1;

不会再有其他可能了，**我们把**a**端的值作为电路的输出**。

现在为保存信息你需要同时设置S端和R端，但你的输入是有一个，为此你对电路进行了简答的改造：  

![image-20241103174318352](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103174318352.png)

当D为0时，整个电路保存的就是0，否则就是1。  

## 指令集

指令集告诉我们 CPU 可以执行什么指令，每种指令需要提供什么样的操作数。不同类型的CPU会有不同的指令集。  

## 指挥家

现在我们的电路有了计算功能、存储功能，还可以通过指令告诉该电路执行什么操作，还有一个问题没有解决。  这个问题就是靠什么来协调靠什么来同步各个部分让它们协同工作呢？  假设我们要计算1+1，这两个数分别来自寄存器R1 和 R2，要知道寄存器中可以保存任意值，我们怎么能确保加法器开始工作时R1****R2中在这一时刻保存的都是1而不是其它数？ 

负责指挥角色的就是时钟信号。时钟信号就像指挥家手里的拿的指挥棒，**指挥棒挥动一下整个乐队会整齐划一的有个相应动作**，同样的，在时钟信号的每一次电压改变，整个电路中的各个寄存器(也就是整个电路的状态)会更新一下，这样我们就能确保整个电路协同工作不会这里提到的问题。

CPU的主频是说一秒钟指挥棒挥动了多少次，当然主频越高CPU在一秒内完成的操作也就越多  

# 进程与线程

## 同步调用

### 同一个线程间的同步调用

一般的函数调用都是同步的，就像这样：  

```
funcA() {
    // 等待函数funcB执行完成
    funcB();
    // 继续接下来的流程
}
```

funcA调用funcB，那么在funcB执行完前，funcA中的后续代码都不会被执行，也就是说funcA必须**等待**funcB执行完成，就像这样：  

![image-20241103191308388](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103191308388.png)

一般来说，像这种同步调用，funcA和funcB是运行在同一个线程中的，这是最为常见的情况。  

### 不同线程间的同步调用

但值得注意的是，即使运行在两个不能线程中的函数也可以进行同步调用，像进行IO操作时实际上底层是通过系统调用的方式向操作系统发出请求的，比如磁盘文件读取：  

```
read(file, buf);
```

阻塞式I/O，在read函数返回前程序是无法继续向前推进的  

```
read(file, buf);
// 程序暂停运行，
// 等待文件读取完成后继续运行
```

![image-20241103191508337](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103191508337.png)

只有当read函数返回后程序才可以被继续执行。

当然，这也是同步调用，但是和上面的同步调用不同的是，函数和被调函数运行在不同的线程中。

>同步调用和函数与被调函数是否运行在同一个线程是没有关系的。  

## 异步调用

以磁盘文件读取为例。在函数的同步调用方式下，文件读取完之前调用方是无法继续向前推进的，但如果read函数可以异步调用情况就不一样了。

假如read函数可以异步调用的话，即使文件还没有读取完成，read函数也可以立即返回。

```
read(file, buff);
// read函数立即返回
// 不会阻塞当前程序
```

![image-20241103191637601](https://raw.githubusercontent.com/qhbsss/Pictures/main/Blog_Picturesimage-20241103191637601.png)

在异步这种调用方式下，调用方不会被阻塞，函数调用完成后可以**立即**执行接下来的程序。

这时异步的重点就在于调用方接下来的程序执行可以和文件读取**同时**进行，从上图中我们也能看出这一点，这就是异步的高效之处。

> 现代磁盘想内存copy数据时无需借助CPU的帮助，这就是所谓的DMA(Direct Memory Access)  

### 异步调用感知方式

在同步调用下，调用方不再继续执行而是暂停等待，被调函数执行完后很自然的就是调用方继续执行，那么异步调用下调用方怎知到被调函数是否执行完成呢？  

这就分为了两种情况：

1. 调用方根本就不关心执行结果

2. 调用方后续需要知道执行结果

第一种情况比较简单，该情况无需讨论。

第二种情况下就比较有趣了，通常有两种实现方式：

一种是通知机制，也就是说当任务执行完成后发送信号用来通知调用方任务完成，注意这里的信号就有很多实现方式了，Linux中的signal，或者使用信号量等机制都可以实现。

另一种是就是回调，也就是我们常说的callback

>eg:
>
>假定处理一次用户请求需要经过步骤A、B、C然后读取数据库，数据库读取完成后需要经过步骤D、E、F.
>
> 一个请求需要经过七个步骤，其中前三个是在主线程中完成的，后四个是在数据库线程中完成的，那么数据库线程是怎么知道查完数据库后要处理D、E、F这几个步骤呢？  
>
>将D、E、F这几个步骤封装到第一个函数中，我们将该函数命名为handle_DEF_after_DB_query:  
>
>```
>void handle_DEF_after_DB_query () {
>    D;
>    E;
>    F;
>}
>```
>
>这样主线程在发送数据库查询请求时将该函数一并当做参数传递过去：  
>
>```
>DB_query(request, handle_DEF_after_DB_query);
>```
>
>数据库线程处理完查询后直接调用handle_DEF_after_DB_query就可以了，这就是回调函数的作用。
>
>也有的同学可能会有疑问，为什么这个函数要传递给数据库线程而不是数据库线程自己定义自己调用呢？
>
>因为从软件组织结构上讲，这不是数据库线程该做的工作。
>
>数据库线程需要做的仅仅就是查询数据库、然后调用一个处理函数，
>
>**至于这个处理函数做了些什么数据库线程根本就不关心，也不应该关心**。
>
>你可以传入各种各样的回调函数。也就是说数据库系统可以针对回调函数这一抽象的函数变量来编程，从而更好的应对变化，因为回调函数的内容改变不会影响到数据库线程的逻辑，而如果数据库线程自己定义处理函数那么这种设计就没有灵活性可言了。
>
>而从软件开发的角度看，假设数据库线程逻辑是其它团队研发的，并用作库提供给其它团队，当数据库团队在研发时怎么可能知道数据库查询后该怎么处理呢，因此该团队在编写代码时简单的使用一个回调函数即可。
>
>与此同时，显然只有使用方才知道查询完数据库后该做些什么，因此使用方在使用时简单的传入这个回调函数就可以了。
>
>这样数据库线程的团队就和使用方团队就实现了所谓的解耦。