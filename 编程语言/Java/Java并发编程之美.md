[TOC]

# 虚假唤醒

一个线程可以从挂起状态变为可以运行状态（也就是被唤醒），即使该线程没有被其他线程调用notify（）、notifyAll（）方法进行通知，或者被中断，或者等待超时，这就是所谓的虚假唤醒。

虽然虚假唤醒在应用实践中很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中调用wait（）方法进行防范。退出循环的条件是满足了唤醒该线程的条件。

```
synchronized (obj) {
        while (条件不满足){
          obj.wait();
          }
}
```

如上代码是经典的调用共享变量wait（）方法的实例，首先通过同步块获取obj上面的监视器锁，然后在while循环内调用obj的wait（）方法。

>eg: https://blog.csdn.net/weixin_45668482/article/details/117373700

# wait(long timeout)函数

该方法相比wait（）方法多了一个超时参数，它的不同之处在于，如果一个线程调用共享对象的该方法挂起后，没有在指定的timeout ms时间内被其他线程调用该共享变量的notify（）或者notifyAll（）方法唤醒，那么该函数还是会因为超时而返回。如果将timeout设置为0则和wait方法效果一样，因为在wait方法内部就是调用了wait（0）。

> 只是唤醒，仍需要竞争锁

# sleep和yield区别

sleep与yield方法的区别在于，当线程调用sleep方法时调用线程会被阻塞挂起指定的时间，在这期间线程调度器不会去调度该线程。而调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行。

# 线程中断

Java中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。