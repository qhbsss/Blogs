# Java反射
## 概念
Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。
本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。
## Java反射加载过程
首先理解类的加载过程
1）编译时期：执行 javac 命令对.java文件进行编译，生成一个或多个字节码文件（即.class文件）；
2）运行时期：执行 java 命令对字节码文件进行解释运行，首先要进行类的加载，加载到内存的类称为运行时类，即Class类型的一个对象；
3）这个Class类型对象存放在方法区中，作为方法区中类数据的访问入口，所有对类数据的访问都要通过这个Class类型对象（反射机制也就是从内存中找到了这个Class类型对象，再通过这个对象获取类的属性、方法、构造器等所有信息）。
## java反射原理
>java的反射是指运行时动态地加载类并使用相关的对象方法，new一个对象是在编译时静态加载的，在编译期间就知道了类对象的信息，但是动态加载时，编译期间不能确定类的信息，需要在运行时去寻找类的信息，而java有字节码这个中间状态，能够在运行时去寻找对应类的class字节码文件，进而找到对应类的信息并进行操作。而C++这类语言在编译时就确定了所有的信息，无法实现动态加载。

Java语言的跨平台是它的最大亮点之一，为了达到平台惯性，它就不得不多一个中间步骤，也就是生成字节码文件。对于一个Java源文件来说，需要用javac命令把源文件编译成class文件，这个class文件是计算机无法直接识别的，但是却可以被Java虚拟机所认识，所以在运行一个Java程序的时候，肯定是要启动一个Java虚拟机，然后在由虚拟机去加载这些class文件，如图所示：
![](https://img-blog.csdn.net/20160808210731495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
>为什么c++没有反射？
对于像c,c++这类高级计算机语言来说，它们的编译器（例如：Unix的CC命令，Windows的CL命令）都是直接把源码直接编译成计算机可以认识的机器码，如exe，dll之类的文件，然后直接运行即可。c++源码编译以后，生成的是特定机器可以直接运行的文件，而Java源码经过编译后，生成的是中间的字节码文件，这些字节码文件是需要放在JVM中运行的，而JVM是有多个平台版本的。因此，Java是具有跨平台的，而C++没有。

我们用普通的方式使用一个类的时候，类是静态加载的,而使用Class.forName(“XXX”)这种方式，则属于动态加载一个类.静态加载的类在编译的时候就能确定该类是否存在，但动态加载一个类的时候却无法在编译阶段确定是否存在该类，而是在运行时候才能够确定是否有这个类。
