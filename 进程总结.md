[TOC]
# Linux中进程与线程的区别
Linux使用task_struct来描述进程和线程

- 一个进程由于其运行空间的不同, 从而有内核线程和用户进程的区分, 内核线程运行在内核空间, 之所以称之为线程是因为它没有虚拟地址空间, 只能访问内核的代码和数据, 而用户进程则运行在用户空间, 不能直接访问内核的数据但是可以通过中断, 系统调用等方式从用户态陷入内核态，但是内核态只是进程的一种状态, 与内核线程有本质区别

- 用户进程运行在用户空间上, 而一些通过共享资源实现的一组进程我们称之为线程组, Linux下内核其实本质上没有线程的概念, Linux下线程其实上是与其他进程共享某些资源的进程而已。但是我们习惯上还是称他们为线程或者轻量级进程

因此, Linux上进程分3种，内核线程（或者叫核心进程）、用户进程、用户线程, 当然如果更严谨的，你也可以认为用户进程和用户线程都是用户进程。

1. 内核线程拥有 进程描述符、PID、进程正文段、核心堆栈

2. 用户进程拥有 进程描述符、PID、进程正文段、核心堆栈 、用户空间的数据段和堆栈

3. 用户线程拥有 进程描述符、PID、进程正文段、核心堆栈，同父进程共享用户空间的数据段和堆栈

>用户线程也可以通过exec函数族拥有自己的用户空间的数据段和堆栈，成为用户进程。
# 进程描述符（PCB）
Linux系统 对线程和进程并不特别区分。线程仅仅被视为一个与其他线程共享某些资源的进程。每个线程都拥有唯一自己的task_struct。
Linux下只有一种类型的进程，那就是task_struct，linux其实没有线程的概念, 只是将那些与其他进程共享资源的进程称之为线程。

内核调度的对象是根据task_struct结构体。可以说是线程，而不是进程。
![](https://user-images.githubusercontent.com/87457873/127093984-949e7c2a-e29b-495f-a88d-437b84008205.png)
linux通过task_struct结构体描述一个进程。

- mm 成员：描述内存资源
- fs 成员：描述文件系统资源
- files 成员：进程运行时打开了多少文件，fd的数组
- signal 成员：进程接收的信号资源

Linux通过slab分配器分配task_struct结构，只需在栈底创建新的结构，struct thread_info。
每个任务的thread_info结构在它的内核栈的尾端分配。(每个进程都有自己的虚拟内存空间，其中虚拟内存中的内核栈的底端分配thread_info结构)
![](https://images2018.cnblogs.com/blog/811006/201808/811006-20180830003940650-697839528.png)

>在内核态（比如应用进程执行系统调用）时，进程运行需要自己的堆栈信息（不是原用户空间中的栈），而是使用内核空间中的栈，这个栈就是进程的内核栈
内核线程不需要访问用户空间内存，这是再好不过了。所以内核线程的task_struct的mm域为空
但是刚才说过，内核线程还有核心堆栈，没有mm怎么访问它的核心堆栈呢？这个核心堆栈跟task_struct的thread_info共享8k的空间，所以不用mm描述。
但是内核线程总要访问内核空间的其他内核啊，没有mm域毕竟是不行的。
所以内核线程被调用时, 内核会将其task_strcut的active_mm指向前一个被调度出的进程的mm域, 在需要的时候，内核线程可以使用前一个进程的内存描述符。
因为内核线程不访问用户空间，只操作内核空间内存，而所有进程的内核空间都是一样的。这样就省下了一个mm域的内存。

## task_struct与thread_info及stack三者的关系
在linux内核中进程以及线程（多线程也是通过一组轻量级进程实现的）都是通过task_struct结构体来描述的，我们称它为进程描述符。

而thread_info则是一个与进程描述符相关的小数据结构，它同进程的内核态栈stack存放在一个单独为进程分配的内存区域。由于这个内存区域同时保存了thread_info和stack，所以使用了thread_union联合体来定义。得到stack，thread_info或task_struct任意一个数据结构的地址，就可以很快得到另外两个数据的地址。
### eg:
通过crash工具在ubuntu系统上做个实验，来窥视一下某个进程的进程描述符,以进程systemd进程为例，其pid=1
```bash
crash> task 1

PID: 1 TASK: ffff88007c898000 CPU: 1 COMMAND: "systemd"

struct task_struct {

state = 1,

stack = 0xffff88007c894000,

usage = {

counter = 2

}
```
可以看到systemd进程的task_struct结构体指针task=0xffff88007c898000

通过task->stack这个结构体成员即可定位到进程的内核栈地址 stack=0xffff88007c894000
![](https://img2022.cnblogs.com/blog/2339862/202209/2339862-20220902145637795-1681686843.png)
另外从图可以看到，thread_info和stack处于同一地址空间，且thread_info在这段地址空间的最低地址处，而且这个地址空间是以THREAD_SIZE对齐的，所以只要将stack地址的最低N位变为0，即可得到thread_info的地址（2^N=THREAD_SIZE)

例如当THREAD_SZIE=8K时，systemd的thread_info地址就等于0xffff88007c894000&(~(0x1FFF)) = 0xffff88007c89400

而通过thread_info->task这个成员变量，又能访问到进程的task_struct结构体，这样就形成了task_struct, thread_info,stack三者之间的关系网，知道其中任何一个，都可以快速的访问到另外两个，提高了数据存取的效率。
# Linux中三个特殊的进程
1. idle进程，或者也称为swapper进程。：

该进程是Linux中的第一个进程（线程），PID为0；

idle进程是init进程和kthreadd进程（内核线程）的父进程；

2. init进程：

init进程是Linux中第一个用户空间的进程，PID为1；

init进程是其他用户空间进程的直接或间接父进程；

需要注意的是，在新版本的centos系统中，已经使用 systemd 取代 init 作为1号进程

3. kthreadd（内核线程）：

kthreadd线程是内核空间其他内核线程的直接或间接父进程，PID为2；

kthreadd线程负责内核线程的创建工作；

## idle进程、init进程、kthreadd进程的创建
kthreadd进程是在内核初始化start_kernel（）的最后rest_init（）函数中，由0号进程（swapper进程）创建了两个进程：

init进程（PID = 1, PPID = 0）
kthreadd进程（PID = 2, PPID = 0）
在start_kernel函数中调用了rest_init函数，在rest_init函数中创建了kernel_init、kthreadd内核线程:

>rest_init是idle进程调用的，因此 idle进程 是所有进程的最上层ppid，即0号进程
```c
 

noinline void __ref rest_init(void)
{
	struct task_struct *tsk;
	int pid;

	rcu_scheduler_starting();
	/*
	 * We need to spawn init first so that it obtains pid 1, however
	 * the init task will end up wanting to create kthreads, which, if
	 * we schedule it before we create kthreadd, will OOPS.
	 */
	pid = kernel_thread(kernel_init, NULL, CLONE_FS);                 //创建init进程，入参kernel_init是进程的执行体，类似java线程的run函数
	/*
	 * Pin init on the boot CPU. Task migration is not properly working
	 * until sched_init_smp() has been run. It will set the allowed
	 * CPUs for init to the non isolated CPUs.
	 */
	rcu_read_lock();
	tsk = find_task_by_pid_ns(pid, &init_pid_ns);
	set_cpus_allowed_ptr(tsk, cpumask_of(smp_processor_id()));
	rcu_read_unlock();

	numa_default_policy();
	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);       //创建kthreadd进程，入参kthreadd是进程的执行体，类似java线程的run函数
	rcu_read_lock();
	kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);
	rcu_read_unlock();

	/*
	 * Enable might_sleep() and smp_processor_id() checks.
	 * They cannot be enabled earlier because with CONFIG_PREEMPTION=y
	 * kernel_thread() would trigger might_sleep() splats. With
	 * CONFIG_PREEMPT_VOLUNTARY=y the init task might have scheduled
	 * already, but it's stuck on the kthreadd_done completion.
	 */
	system_state = SYSTEM_SCHEDULING;

	complete(&kthreadd_done);                   // 等待kthreadd创建完毕

	/*
	 * The boot idle thread must execute schedule()
	 * at least once to get things moving:
	 */
	schedule_preempt_disabled();
	/* Call into cpu_idle with preempt disabled */
	cpu_startup_entry(CPUHP_ONLINE);
}
 
```
## kthreadd进程
kthreadd就是Linux的2号进程，这个进程在Linux内核中非常的重要，他是其他内核线程的父进程或者祖先进程(这个可以通过上面的PPID为2的进程可以看出，这些重要线程包括kworker、kblockd、khugepaged…)，即其他进程都是通过2号进程创建的，2号进程轮询创建进程的任务队列。
### kthreadd进程的启动
kthreadd是进程的执行体，kthreadd进程的任务就是不断轮询，等待创建线程，如果任务队列为空，则线程主动让出cpu（调用schedule后会让出cpu,本线程会睡眠）：如果不为空，则依次从任务队列中取出任务，然后创建相应的线程。如此往复，直到永远…
```c
int kthreadd(void *unused)
{
	struct task_struct *tsk = current;

	/* Setup a clean context for our children to inherit. */
	set_task_comm(tsk, "kthreadd");
	ignore_signals(tsk);
	set_cpus_allowed_ptr(tsk, housekeeping_cpumask(HK_FLAG_KTHREAD));   /*允许kthreadd在任意cpu上执行*/
	set_mems_allowed(node_states[N_MEMORY]);

	current->flags |= PF_NOFREEZE;
	cgroup_init_kthreadd();

	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (list_empty(&kthread_create_list)) /* 判断内核线程链表是否为空 */
			schedule(); /* 若没有需要创建的内核线程，进行一次调度，让出cpu */
		__set_current_state(TASK_RUNNING);

		spin_lock(&kthread_create_lock);
		while (!list_empty(&kthread_create_list)) {    /*依次取出任务*/
			struct kthread_create_info *create;

			create = list_entry(kthread_create_list.next,
					    struct kthread_create_info, list);
			list_del_init(&create->list);       /*从任务列表中摘除*/
			spin_unlock(&kthread_create_lock);
                        /* 只要kthread_create_list不为空，就根据表中元素创建内核线程 */
			create_kthread(create);       //创建子进程

			spin_lock(&kthread_create_lock);
		}
		spin_unlock(&kthread_create_lock);
	}

	return 0;
}
            
```
### kthreadd进程创建子进程
创建子进程，会调用create_kthread函数，在create_kthread函数中会通过调用kernel_thread函数来创建新进程，且新进程的执行函数为kthread(类似java线程的run方法)
```c
static void create_kthread(struct kthread_create_info *create)
{
	int pid;
 
#ifdef CONFIG_NUMA
	current->pref_node_fork = create->node;
#endif
	/* We want our own signal handler (we take no signals by default). */
	pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);/*开始创建线程，会阻塞*/
	if (pid < 0) {
		/* If user was SIGKILLed, I release the structure. */
		struct completion *done = xchg(&create->done, NULL);
 
		if (!done) {
			kfree(create);
			return;
		}
		create->result = ERR_PTR(pid);
		complete(done);
	}
}
```
kernel_thread接口刚才在rest_init接口中遇到过，内核就是通过kernel_thread接口创建的init进程和kthreadd进程。这里再次使用它创建新线程，新的线程执行体统一为kthead。下面我们看看kthread函数的内容：
```c
static int kthread(void *_create)
{
	/* Copy data: it's on kthread's stack */
	struct kthread_create_info *create = _create;
	int (*threadfn)(void *data) = create->threadfn;
	void *data = create->data;
	struct completion *done;
	struct kthread *self;
	int ret;
 
	self = kzalloc(sizeof(*self), GFP_KERNEL);
	set_kthread_struct(self);
 
	/* If user was SIGKILLed, I release the structure. */
	done = xchg(&create->done, NULL);
	if (!done) {
		kfree(create);
		do_exit(-EINTR);
	}
 
	if (!self) {
		create->result = ERR_PTR(-ENOMEM);
		complete(done);
		do_exit(-ENOMEM);
	}
 
	self->data = data;
	init_completion(&self->exited);
	init_completion(&self->parked);
	current->vfork_done = &self->exited;
 
	/* OK, tell user we're spawned, wait for stop or wakeup */
	__set_current_state(TASK_UNINTERRUPTIBLE);
	create->result = current;
	complete(done);
	schedule();/*睡眠，一直。直到被唤醒*/
 
	ret = -EINTR;
	if (!test_bit(KTHREAD_SHOULD_STOP, &self->flags)) {/*唤醒后如果此线程不需要stop*/
		cgroup_kthread_ready();
		__kthread_parkme(self);
		ret = threadfn(data);/*执行指定的函数体*/
	}
	do_exit(ret);
}
```
从kthread函数可以看出，新线程创建成功后，会一直睡眠（使用schedule主动让出CPU并睡眠），直到有人唤醒它（wake_up_process）;线程被唤醒后，并且不需要stop, 则执行指定的函数体（ threadfn(data) ）。
### kthreadd的工作流程总结

上图中显示了内核创建线程的基本流程：

①某一个线程A（左上那个圈）调用kthread_create函数来创建新线程，调用后阻塞；kthread_create会将任务封装后添加到kthreadd监控的工作队列中；

②kthreadd进程检测到工作队列中有任务，则结束休眠状态，通过调用create_kthread函数创建线程，最后调用到kernel_thread --> do_fork来创建线程，且新线程执行体为kthead

③新线程创建成功后，执行kthead，kthreadd线程则继续睡眠等待创建新进程；

④线程A调用kthread_create返回后，在合适的时候通过wake_up_process(pid)来唤醒新创建的线程

⑤新创建的线程在kthead执行体中被唤醒，检测到是否需要stop,在不需要stop时，执行用户指定的线程执行体。（线程执行体发生了变化：先执行默认的kthead,然后才是用户指定的threadfn，当然也可能直接执行do_exit退出线程）
## init进程
init进程由idle通过kernel_thread创建，在内核空间完成初始化后，加载init程序

在这里我们就主要讲解下init进程，init进程由0进程创建，完成系统的初始化，是系统中所有其他用户进程的祖先进程

Linux中的所有进程都是由init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成后，init将变成为守护进程监视系统其他进程。

所以说init进程是Linux系统操作中不可缺少的程序之一，如果内核找不到init进程就会试着运行/bin/sh，如果运行失败，系统的启动也会失败。

### init进程启动
创建1号进程，传入 kernel_init方法体
```c
static int __ref kernel_init(void *unused)
{
	int ret;

	kernel_init_freeable();             //kernel_init_freeable函数中就会做各种外设驱动的初始化
	/* need to finish all async __init code before freeing the memory */
	async_synchronize_full();
	kprobe_free_init_mem();
	ftrace_free_init_mem();
	free_initmem();
	mark_readonly();

	/*
	 * Kernel mappings are now finalized - update the userspace page-table
	 * to finalize PTI.
	 */
	pti_finalize();

	system_state = SYSTEM_RUNNING;
	numa_default_policy();

	rcu_end_inkernel_boot();

	do_sysctl_args();

	if (ramdisk_execute_command) {
		ret = run_init_process(ramdisk_execute_command);
		if (!ret)
			return 0;
		pr_err("Failed to execute %s (error %d)\n",
		       ramdisk_execute_command, ret);
	}

	/*
	 * We try each of these until one succeeds.
	 *
	 * The Bourne shell can be used instead of init if we are
	 * trying to recover a really broken machine.
	 */
	if (execute_command) {
		ret = run_init_process(execute_command);
		if (!ret)
			return 0;
		panic("Requested init %s failed (error %d).",
		      execute_command, ret);
	}

	if (CONFIG_DEFAULT_INIT[0] != '\0') {
		ret = run_init_process(CONFIG_DEFAULT_INIT);
		if (ret)
			pr_err("Default init %s failed (error %d)\n",
			       CONFIG_DEFAULT_INIT, ret);
		else
			return 0;
	}
/* 调用系统根目录下的init文件，会在以下几个路径中加载init进程 */
/* 在Android源码中，init进程源码的位置为：https://www.androidos.net.cn/android/10.0.0_r6/xref/system/core/init/init.cpp */
	if (!try_to_run_init_process("/sbin/init") ||
	    !try_to_run_init_process("/etc/init") ||
	    !try_to_run_init_process("/bin/init") ||
	    !try_to_run_init_process("/bin/sh"))
		return 0;        

	panic("No working init found.  Try passing init= option to kernel. "
	      "See Linux Documentation/admin-guide/init.rst for guidance.");
}
```
kernel_init_freeable函数中就会做各种外设驱动的初始化
最主要的工作就是调用 init可以执行文件，即开机自动运行的程序，通过Init配置文件在约定的路径下，会被自动读取
1号进程就完美的创建成功了，而且也成功执行了init可执行文件
# 用户态线程和内核态线程的映射关系
用户级线程本身只是一堆数据用户程序，位于用户空间。内核级线程是系统中“真正”的线程，因此对于用户级线程来说，用户程序运行用户级线程，必须要通过映射到内核级线程后，在内核级线程上运行它。
