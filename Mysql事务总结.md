# Mysql事务总结

## mysql事务需要支持的特性：

A(原子性)C(一致性)I(隔离性)D(持久性)

## 不同隔离级别可能发生的并发问题：

| 隔离级别\并发问题  | 脏读  |  不可重复读 | 幻读  |
| :------------: | :------------: | :------------: | :------------: |
| 读未提交  | &#10004;  | &#10004;  |  &#10004; |
| 读已提交  |   |  &#10004; |  &#10004; |
| 可重复读 |   |   | &#10004;  |
| 串行化  |   |   |   |

## mysql中读的两种方式：
**快照读(一致性非锁定读)**：普通的 select 语句（不包括 select ... lock in share mode ,select ... for update），innodb中，在快照读下是靠MVCC（多版本并发控制）来保证隔离性的
**当前读(锁定读)**：如下语句select ... lock in share mode，select ... for update，insert、update、delete 操作，innodb中，当前读是靠加锁来保证隔离性的，同一事务中加的锁直到事务提交才会释放

## 可重复读隔离级别下MVCC工作原理
MVCC 的实现依赖于：**隐藏字段、Read View、undo log**，在可重复读隔离级别下，当在事务中第一次执行快照读时，会生成整个事务的ReadView，该ReadView在当前事务下是不会发生改变的，记录对于后续事务中快照读的可见性根据记录隐藏字段中的trx_id和事务的ReadView来决定，当记录的tri_id对于事务的ReadView是可见的，就读取当前页面中的记录，否则读取记录在undo_log中的历史版本
**Read View中包含以下字段**：
![](./images/image.png)
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/事务隔离/readview结构.drawio.png)

![](./images/1724059013810_image.png)
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/事务隔离/ReadView.drawio.png)
**记录中包含隐藏字段**:
![](./images/1724060825362_image.png)
**PS**:执行insert和update等更新操作时会生成新的记录版本，哪怕是在同一个事务下，但是insert和update不会更新事务的readview，insert和update更新的记录对于事务中后续快照读可见是通过生成trx_id相同的新的记录版本实现的
![](./images/1724063774636_image.png)

## mysql中的锁
### 全局锁
不支持可重复读隔离级别的引擎进行数据库备份时使用全局锁使数据库处于只读状态，支持可重复读的引擎备份时可以不用加全局锁
```sql
#加全局锁
flush tables with read lock
#释放全局锁
unlock tables
```
### 表级锁
1. 表锁：表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。
```sql
//表级别的共享锁，也就是读锁；
lock tables t_student read;

//表级别的独占锁，也就是写锁；
lock tables t_student write;

//释放表锁
unlock tables
```
2. 元数据锁（MDL）
**MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。**
不需要显式的使用 MDL，对数据库表进行操作时，会自动给这个表加上MDL：对一张表进行 CRUD 操作时，加的是 MDL 读锁；对一张表做结构变更操作的时候，加的是 MDL 写锁；MDL 是在事务提交后才会释放。
当有线程在执行 select 语句（加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（释放 MDL 读锁）。反之，当有线程对表结构进行变更（加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（释放 MDL 写锁）。
3. 意向锁
**意向锁的目的是为了快速判断表里是否有记录被加锁。**如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。
4. AUTO-INC 锁
表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。AUTO-INC 锁是特殊的表锁机制，锁不是在一个事务提交后才释放，而是在执行完插入语句后就会立即释放。在插入数据时，MySQL 会加一个表级别的 AUTO-INC 锁，然后会为被 AUTO_INCREMENT 修饰的字段赋递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。那么，一个事务在持有 AUTO-INC 锁的过程中，其他的事务如果要向该表插入语句都会被阻塞，从而**保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。**

### 行级锁
InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为锁定读。
```sql
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```
1. **Record Lock**，记录锁，也就是仅仅把一条记录锁上；
锁住的是一条记录,有 S 锁和 X 锁之分的：
当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。
2. **Gap Lock**，间隙锁，锁定一个范围，但是不包含记录本身；
Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。
3. **Next-Key Lock**：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
next-key lock 是包含间隙锁 + 记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。
4. **插入意向锁**
一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。
如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。
插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。

## mysql在RR隔离级别下如何解决脏读、不可重复读、幻读等并发问题
1. 脏读
如果一个事务「读到」了另一个「**未提交事务修改过的数据**」，就意味着发生了「脏读」现象。
2. 不可重复读
在一个事务事务「读到」了另一个「**已提交事务修改过的数据**」，就意味着发生了「不可重复读」现象。
3. 幻读
在一个事务内多次查询某个符合查询条件的「**记录数量**」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。

对于脏读和不可重复读（幻读视作不可重复读的特殊情况），RR下的快照读在事务开始时生成了ReadView，其他事务的修改不管是否已提交，对于本事务的快照读都不可见，而对于当前读，当前读时都加了锁，其他事务无法修改锁住的数据，也解决了当前读下的脏读和幻读问题，但是对于先快照读，再当前读的情况，可以解决脏读，因为脏读时其他事务对于相同数据的锁未释放，本事务的当前读会被阻塞，但是对于不可重复读，还是有可能发生读取到其他事务修改数据的情况。
